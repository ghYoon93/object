- 메시지는 송신자의 의도를 표현한다.

## DiscountCondition 개선하기
`DiscountCondition`이 변경될 수 있는 서로 다른 이유 (낮은 응집도)
- 새로운 할인 조건 추가
- 순번 조건을 판단하는 로직 변경
- 기간 조건을 판단하는 로직 변경

- 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋다.
- 변경의 이유가 하나 이상인 클래스에는 위험 징후를 또렷하게 드러내는 몇 가지 패턴이 존재

- 코드를 통해 변경의 이유를 파악할 수 있는 방법
  - **인스턴스 변수가 초기화되는 시점 살펴보기**
    - 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
    - 응집도가 낮은 클래스는 인스턴스를 생성할 때 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다.
    - 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.
  - **메서드들이 인스턴스 변수를 사용하는 방식 살펴보기**
    - 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.
    - 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다.
    - **속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.**

- 낮은 응집도의 징후
  - 클래스가 하나 이상의 이류로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라.
  - 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화되는 속성의 그룹을 기준으로 클래스를 분리하라.
  - 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라.

- 응집도 높은 메서드로 긴 메서드를 분해하는 방법?

## 타입 분리하기
- `SequenceCondition`과 `PeriodCondition`이라는 두 개의 클래스로 분리하기
- 클래스 분리 후 새로운 문제
  - `Movie`의 인스턴스가 `SequenceCondition`과 `PeriodCondition` 두 개의 서로 다른 클래스의 인스턴스 모두와 협력할 수 있어야 한다.
  - 해결 방법
    - SequenceCondition의 목록과 PeriodCondition의 목록을 따로 유지
    - 문제 1. `Movie` 클래스가 `PeriodCondtion`과 `SequenceCondition` 클래스 양쪽 모두에게 결합된다.
    - 문제 2. 수정 후에 새로운 할인 조건을 추가하기가 더 어려워졌다.
  - 변경과 캡슐화라는 관점에서 보면 전체적으로 설계의 품질이 나빠졌다.

## 다형성을 통해 분리하기
- `Movie` 입장에서는 할인 가능 여부를 반환해 주기만 하면 상관없다.
- 동일한 책임 수행 = 동일한 역할 수행
- 객체의 암시적인 타입에 따라 행동을 분기해야 한다면 암시적인 타입을 명시적인 클래스로 정의하고 행동을 나눔으로써 응집도 문제를 해결할 수 있다.
- POLYMORPHISM(다형성) 패턴 : 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하는 것.

## 변경으로부터 보호하기
- PROTECTED VARIATIONS(변경 보호) 패턴 : 변경을 캡슐화하도록 책임을 할당하는 것
- 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 클래스를 분해하고 **POLYMORPHISM** 패턴에 따라 책임을 분산시켜라.
- 얘측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면 **PROTECTED VARIATIONS** 패턴에 따라 책임을 안정적인 인터페이스 뒤로 변경을 캡슐화하라.

## Movie 를클래스 개선하기
- `Movie`의 응집도
  - 금액 할인 정책 영화와 비율 할인 정책 영화라는 두 가지 타입을 하나의 클래스 안에 구현하기 때문에 응집도가 낮다.
  - 역할의 개념을 도입해서 협력을 다형적으로 만들자.
- 객체지향 설계의 기본은 책임과 협력에 초점을 맞추는 것이다.
- 객체에게 중요한 것은 상태가 아니라 행동
- 구현을 가이드할 수 있는 도메인 모델을 선택하라.
- 객체지향은 도메인의 개념과 구조를 반영한 코드를 가능하게 만들기 때문에 도메인의 구조가 코드의 구조를 이끌어 내는 것은 자연스러울 뿐만 아니라 바람직한 것이다.

