- 설계를 진행하는 동안 데이터가 아닌 책임 관점에서 사고하기 위해서는 충분한 경험과 학습이 필요하다.
  - 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하자.
  - 명확하게 드러나는 책임들을 올바른 위치로 이동시키다.
- 주의할 점은 코드를 수정한 후에 겉으로 드러나는 동작이 바뀌어서는 안된다.
- 캡슐화를 향상시키고, 응집도를 높이도, 결합도를 낮춰야 하지만 동작은 그대로 유지해야 한다.

## 메서드 응집도
> 응집도 높은 메서드를 분해하는 방법
- ReservationAgency의 문제점
  - 어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는 데 너무 많은 시간이 걸린다.
  - 하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.
  - 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다.
  - 로직의 일부만 재사용하는 것이 불가능하다.
  - 카드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다.
- 명령문들의 그룹으로 구성되고 각 그룹에 주석을 달아야 할 필요가 있다면 그 메서드의 응집도는 낮은 것이다.
  - 주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높여라.
- 객체로 책임을 분배할 때 가장 먼저 할 일
  - 메서드를 응집도 있는 수준으로 분해하는 것.
- ReservationAgency는 오직 하나의 작업만 수행하고, 하나의 변경 이유만 가지는 작고, 명확하고, 응집도가 높은 메서드들로 구성돼 있다.
  - 코드를 작은 메서드로 분해하여 전체적인 흐름을 이해하기 쉬워졌다.
  - 변경하기 쉬워졌다.
  - 변경 가능한 설계를 이끌어 내는 기반이 된다.
- `ReservationAgency`의 응집도를 높이는 방법
  - 변경의 이유가 다른 메서드들을 적절한 위치로 분배 필요
    - 각 메서드가 사용하는 데이터를 정의하고 있는 클래스

## 객체를 자율적으로 만들자
- 자율적인 객체를 만드는 지름길
  - 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시켜 자신의 데이터는 자기 스스로 처리하도록 만드는 것
- 메서드를 다른 클래스로 이동시킬 때는 인자에 정의된 클래스 중 하나로 이동하는 경우가 일반적
- 이후 POLYMORPHISM과 PROTECTED VARIATIONS 패턴을 차례대로 적용하면 최종 설계와 유사한 모습의 코드를 얻게 될 것이다.