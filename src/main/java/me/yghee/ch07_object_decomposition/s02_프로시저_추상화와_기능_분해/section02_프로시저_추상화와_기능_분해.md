## 메인 함수로서의 시스템
- 기능 분해 관점에서 추상화의 단위
  - 프로시저
  - 시스템은 프로시저를 단위로 분해된다.
- 프로시저
  - 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법
  - 프로시저는 잠재적으로 정보은닉의 가능성을 제시하지만 효과적인 정보은닉 체계를 구축하는 데는 한계가 있다.
  - 프로시저 중심의 기능 분해 관점에서 시스템
    - 입력 값을 계산해서 출력 값을 반환하는 수학의 함수와 동일
- 전동적인 기능 분해 방법
  - 하향식 접근법(Top-Down Approach)
    - 시스템을 구성하는 가장 최상위(topmost) 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법

## 급여 관리 시스템
- 급여 관리 시스템을 구현하기 위해 기능 분해 방법을 사용
- 최상위의 추상적인 함수 정의
  - 시스템의 기능을 표현하는 하나의 문장으로 나타낸다.
- 급여 관리 시스템에 대한 추상적인 최상위 문장
  - 직원의 급여를 계산한다.
- 급여를 계산하는 데 필요한 정보
  - 직원의 이름과 소득세율, 기본급 정보
- 모든 문장이 정제 과정을 거치면서 하나 이상의 좀 더 단순하고 구체적인 문장들의 조합으로 분해돼야 한다.
- 직원의 급여를 계산한다.
    - 사용자로부터 소득세율을 입력받는다.
      - "세율을 입력하세요: " 라는 문장을 화면에 출력한다.
      - 키보드를 통해 세율을 입력받는다.
    - 직원의 급여를 계산한다.
      - 전역 변수에 저장된 직원의 기본급 정보를 얻는다.
      - 급여를 계산한다.
    - 양식에 맞게 결과를 출력한다.
      - "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.
- 기능 분해는 책의 목차를 정리하고 그 안에 내용을 채워 넣는 것과 유사하다.
- 기능 분해가 동작하는 방법과 그에 수반되는 문제점을 이해할 수 있는 가장 효과적인 방법
  - 실제 애플리케이션 코드를 살펴보는 것

## 급여 관리 시스템
- 급여를 계산한다.
```
def main(name)
end
```
- 직원의 급여를 계산한다.
  - 사용자로부터 소득세율을 입력받는다.
  - 직원의 급여를 계산한다.
  - 양식에 맞게 결과를 출력한다.
```
def main(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
end
```
- 사용자로부터 소득세율을 입력받는다.
  - "세율을 입력하세요: "라는 문장을 화면에 출력한다.
  - 키보드를 통해 세율을 입력받는다.
```
def getTaxRate()
  print("세율을 입력하세요: ")
  return gets().chomp().to_f()
end
```
- 직원의 급여를 계산한다.
  - 전역 변수에 저장된 직원의 기본급 정보를 얻는다.
  - 급여를 계산한다.
```
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]

def calculatePayFor(name, taxRate)
  index = $employees.index(name)
  basePay = $basePays[index]
  return basePay - (basePay * taxRate)
end
```

- 양식에 맞게 결과를 출력한다.
  - "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.
```
def describeResult(name, pay)
  return "이름: #{name}, 급여: #{pay}"
end
```

- 체계적이고 이상적인 방법이 불규칙하고 불완전한 인간과 만나는 지점에서 혼란과 동요가 발생한다.

## 하향식 기능 분해의 문제점
- 하향식 기능 분해 방법을 설계에 적용하다 보면 직면하는 문제
  - 시스템은 하나의 메인 함수로 구성돼 있지 않다.
  - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 하낟.
  - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
  - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
  - 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.
- 

### 하나의 메인 함수라는 비현실적인 아이디어
- 어떤 시스템도 최초에 릴리스됐던 당시의 모습을 그대로 유지하지는 않는다.
- 기능이 추가될수록 메인 함수는 동등하게 중요한 여러 함수들 중 하나로 전략하고 만다.
- 실제 시스템에 정상(top)이란 존재하지 않는다.

### 메인 함수의 빈번한 재설계
- 메인 함수를 유일한 정상으로 간주하는 하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다.
- 기존 로직과는 아무런 상관이 없는 새로운 함수의 적절한 위치를 확보해야 하기 때문에 메인 함수의 구조를 급격하게 변경할 수 밖에 없다.
- 모든 직원들의 기본급의 총합을 구하는 기능의 구현은 쉽지만 함수가 들어설 자리가 마땅치 않다는 것이다.
  - 현재 main 함수 안의 로직 전체를 calculatePay라는 함수로 추출한 후 main 함수에서 적절하게 sumOfBasePays 함수와 calculatePay 함수를 호출하는 것이다.
```
def calculatePay(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
```
```
def main(operation, args={})
  case(operation)
  when :pay then calculatePay(args[:name])
  when :basePays then sumOfBasePays()
  end
end
```

### 비즈니스 로직과 사용자 인터페이스의 결합
- 하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다.
- 문제는 비즈니스 로직과 사용자 인터페이스가 변경되는 빈도가 다르다는 것이다.
- 사용자로부터 소득세율을 입력받아 급여를 계산한 후 계산된 결과를 화면에 출력하다.
  - 급여를 계산하는 중요한 비즈니스 로직과 관련된 관심사와 소득세율을 입력받아 결과를 화면에 출력한다는 사용자 인터페이스의 관심사가 한데 섞여 있다는 것을 의미한다.
### 성급하게 결정된 실행 순서
- 설계를 시작하는 시점부터 시스템이 무엇(what)을 해야 하는지가 아니라 어떻게(how) 동작해야 하는지에 집중하도록 만든다.
- 하향식 접근법은 함수들의 실행 순서를 정의하는 시간 제약(temporal constraint)을 강조한다.
- 하향식 접근법을 통해 분해한 함수들은 재사용하기도 어렵다.
  - 상위 함수가 강요하는 문맥 안에서만 의미를 가지기 때문이다.
- 하향식 설계와 관련된 모든 문제의 원인은 **결합도**이다.

### 데이터 변경으로 인한 파급효과
- 하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다는 것이다.

기존 시스템에 아르바이트 직원 추가
```
$employees = ["직원A", "직원B", "직원C", "아르바이트D", "아르바이트E", "아르바이트F"]
$basePays = [400, 300, 250, 1, 1, 1.5]
$hourlys = [false, false, false, true, true, true] // 아르바이트 여부
$timeCards = [0, 0, 0, 120, 120, 120] // 한달 간의 업무 누적 시간 
```

아르바이트 직원의 급여를 계산하는 `calculateHourlyPayFor` 함수 추가
```
def calculateHourlyPayFor(name, taxRate)
  index = $employees.index(name)
  basePay = $basePays[index] * $ timeCards[index]
  return basePay - (basePay * taxRate)
```
직원을 판단하는 `hourly?` 추가
```
def hourly?(name)
  return $hourlys[$employees.index(name)]
end
```

급여 계산하는 `calculatePayFor` 함수 수정
```
def calculatePay(name)
  taxRate = getTaxRate()
  if (hourly?(name)) then
    pay = calculateHourlyPayFor(name, taxRate)
  else
    pay = calculatePayFor(name, taxRate)
  end
  puts(describteResult(name, pay))
end
```

- 코드가 성장하고 라인 수가 증가할수록 전역 데이터를 변경하는 것은 악몽으로 변해간다.
- 데이터 변경으로 인항 영향을 최소화
  - 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 제공되는 함수만 이용해 데이터에 접근해야 한다.
  - 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 한다.
  - 의존성 관리의 핵심
- **정보 은닉과 모듈**
  - 기능 분해가 가진 본질적인 문제를 해결하기 위해 제시된 개념

### 언제 하향식 분해가 유용한가?
- 설계가 어느 정도 안정화 된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하다.
- 작은 프로그램과 개별 알고리즘을 설계할 때
- 이미 해결된 알고리즘을 문서화하고 서술할 때

